#include "dsp_types.h"
#include "dsp_isr.h"
#include "DSP2833x_Device.h"
#include "Application_Control_Variables.h"
#include "dsp_gps.h"

uint8_t I2CRead_flag;
uint8_t gtx_msg_ind_in = 0U;        // Variable to index Gumstix_Message_in
uint8_t gtx_msg_ind_out = 0U;        // Variable to index Gumstix_Message_out
extern uint8_t gps_in_index;            // Variable to index gps_in
uint8_t GpsMessageReady = 0U;


uint8_t g_internal_timing = 0U;    /* 0: external timing - GPS
                                 * 1: internal timing - DSP */

    
// ***********************************************************************
// SCI-A Transmit Interrupt Service
interrupt void SCIA_TX_isr(void)     
{
    extern uint8_t gps_in_flag;
    extern uint8_t *SCI_TX_Message;
    extern uint8_t SciTxQtd;
    extern uint8_t SciTxStatus;

//    copy 16 character into SCI-A TX buffer
    // do while Tx buffer is not full 
    while ((SciaRegs.SCIFFTX.bit.TXFFST != 16U) && (SciTxStatus == 'b')){    
        if (SciTxQtd != 0U){
            SciaRegs.SCITXBUF = *SCI_TX_Message++;
            SciTxQtd--;
        }else{
            SciTxStatus = 'f';
            // It's needed to disable interrupt cus whenever isen't have data to send interrupt will be assert 
            SciaRegs.SCIFFTX.bit.TXFFIENA = 0U;
        }
    }
    // reset this interrupt request
    SciaRegs.SCIFFTX.all |= 0x40U;        
    //Reenable interrupt from group 9
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;     
}


// SCI-A Receive Interrupt Service
interrupt void SCIA_RX_isr(void)
{
    extern uint8_t gps_in[200];
    extern uint8_t gps_in_flag;
    uint16_t i;

    // Whenever the RXFIFO generates an interrupt (16 bytes received), the Timer1 counter will be reset
    // until the moment GPS terminates to send message and remaining data are lower than 16 bytes, that is
    // not sufficient to generates a new interrupt by RXFIFO. So, in such a case, the Timer1 counter are 
    // not reset and an interrupt is generated by Timer1, serviced by its isr.
    CpuTimer1Regs.TIM.all = 0x00000000U;
    
    // Starts Timer1 counter only if the previous interrupt comes from the last GPS message
    if (gps_in_flag == 1U)
    {
        StartCpuTimer1();
        gps_in_flag = 0U;
    }

    for (i = 0U; i < 16U; i++)
    {
        gps_in[gps_in_index++] = SciaRegs.SCIRXBUF.bit.RXDT;
    }
    
    SciaRegs.SCIFFRX.bit.RXFIFORESET = 0U;    // reset RX-FIFO pointer  
    SciaRegs.SCIFFRX.bit.RXFIFORESET = 1U;    // enable RX-operation
    SciaRegs.SCIFFRX.bit.RXFFINTCLR = 1U;    // clear RX-FIFO INT Flag

    //Reenable interrupt from group 9
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP9; 
}




//===========================================================================
// SPI Tx Interrupt Service
// Send data formated in 8 or 16 bits
interrupt void SPI_TxFifoIsr(void)
{
    Uint16 i;

    for (i = 0U; i < 8U; i++)
    {
//        GpioDataRegs.GPATOGGLE.bit.GPIO6 = 1U;
//        SpiaRegs.SPITXBUF = Gumstix_Message_in[gtx_msg_ind_out++] << 8U;//(SPI_RX_Message[i] << 8) & 0xFF00;// 0xAAAA;//(i & 0x00FF) << 8;// & 0x00FF;    // Write data
        /* SpiaRegs.SPITXBUF = (Gumstix_Message_out[gtx_msg_ind_out] << 8U) & 0xFF00U;     */
        /* SpiaRegs.SPITXBUF = Gumstix_Message_out[gtx_msg_ind_out++] & 0xFF00U;            */
    }

    SpiaRegs.SPIFFTX.bit.TXFFINTCLR=1;          // clear Interrupt flag (TXFFINT)
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;        // Issue PIE ack Old value: |=0x20
}


//===========================================================================
// SPI Rx Interrupt Service
// Just read data formated in 16 bits
// ---------
// Para fins de testes, o Gumstix está enviando em hexa: 
// [69 00 00 00 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05]


interrupt void SPI_RxFifoIsr (void)
{
//    Original code
    Uint16 i;
    uint8_t SPI_RX_Message[16];
    uint8_t SPI_received_ok;


    // RX FIFO full
    if (SpiaRegs.SPIFFRX.bit.RXFFINT)        
    {

        for (i = 0U; i < 16U; i++)
        {
            SPI_RX_Message[i] = SpiaRegs.SPIRXBUF & 0x00FFU;    // read data masking 8 bits left
            /* Gumstix_Message_in[gtx_msg_ind_in++] = SPI_RX_Message[i]; */
        }
        SPI_received_ok = 0U;


//        SpiaRegs.SPIFFTX.bit.TXFIFO = 0U;
//        SpiaRegs.SPIFFTX.bit.TXFIFO = 1U;
//    }


    SpiaRegs.SPIFFRX.bit.RXFIFORESET = 0U;    // reset RX FIFO (pointer to 0)
    SpiaRegs.SPIFFRX.bit.RXFIFORESET = 1U;    // re-enable RX FIFO operation
    SpiaRegs.SPIFFRX.bit.RXFFINTCLR = 1U;    // clear Interrupt flag

    } // end-if FIFO full

    
    // RX FIFO overflow
    if (SpiaRegs.SPIFFRX.bit.RXFFOVF)        
    {
        SPI_RX_Message[0] = 0xFFFFU;        // first value is not valid.

        for (i = 1U; i < 16U; i++)
            SPI_RX_Message[i] = SpiaRegs.SPIRXBUF & 0x00FFU;    // read data masking 8 bits left.

        //SPI_FIFO_overflow++;
        SpiaRegs.SPIFFRX.bit.RXFFINTCLR = 1U;         // clear Interrupt flag
        SpiaRegs.SPIFFRX.bit.RXFIFORESET = 0U;    // reset RX FIFO (pointer to 0)
        SpiaRegs.SPIFFRX.bit.RXFIFORESET = 1U;    // re-enable RX FIFO operation
        SpiaRegs.SPIFFRX.bit.RXFFOVFCLR = 1U;      // clear RXFFOVF (overflow flag)
    
    } // end-if RX FIFO overflow

    // SPI without FIFO
    if (SpiaRegs.SPISTS.bit.INT_FLAG)
    {
        while (SpiaRegs.SPISTS.bit.INT_FLAG != 1U) { } 
        SPI_RX_Message[0] = SpiaRegs.SPIRXBUF & 0xFFU;//read

        SpiaRegs.SPITXBUF= 0xCA00U; //write

        while (SpiaRegs.SPISTS.bit.INT_FLAG != 1U) { } 
        SPI_RX_Message[1] = SpiaRegs.SPIRXBUF & 0xFFU;//read
//        SPI_RX_Message[0] = SpiaRegs.SPIRXBUF & 0x00FFU;    // read data masking 8 bits left.        
//        while(SpiaRegs.SPISTS.bit.BUFFULL_FLAG == 1U);
//        SpiaRegs.SPITXBUF = SPI_RX_Message[0] << 8U;
//        SpiaRegs.SPISTS.bit.BUFFULL_FLAG = 1U;
        
    }

    SpiaRegs.SPIFFTX.bit.TXFFIENA = 1U;        // do not enable TX FIFO interrupt, until there is something to send -- enable interrupt on TX FIFO match
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;    // Issue PIE ack Old value: 0x20
}


//===========================================================================
// SPI-CS Interrupt Service
// ------------------------
// Configures RX- and TX-FIFO when SPI transfer initiates and terminates.
interrupt void spi_cs_isr()
{
    uint8_t SPI_received_ok;
    uint16_t i;
    uint16_t cs;
    uint16_t len;

    len = SpiaRegs.SPIFFRX.bit.RXFFST;
    cs = GpioDataRegs.GPADAT.bit.GPIO19;    // cs=0: transfer | cs=1: halt

    if (cs)
    { // end of communication
        // check if there is any byte in the TXFIFO, if does, read them...
        if (len != 0U)
        {
            for (i = 0U; i < len; i++)
            {
                /* Gumstix_Message_in[gtx_msg_ind_in++] = SpiaRegs.SPIRXBUF & 0x00FFU; */    // read data masking 8 bits left
            }
        }
        gtx_msg_ind_out = 0U;
        SPI_received_ok = 1U;
        SpiaRegs.SPIFFRX.bit.RXFIFORESET = 0U;    // reset RX FIFO (pointer to 0)
        SpiaRegs.SPIFFRX.bit.RXFIFORESET = 1U;
    
    }else
    { // start of communication
        gtx_msg_ind_in = 0U;
        SpiaRegs.SPIFFTX.bit.TXFIFO = 0U;    // reset TX FIFO (pointer to 0)
        SpiaRegs.SPIFFTX.bit.TXFIFO = 1U;

//        SpiaRegs.SPIFFRX.bit.RXFIFORESET = 0U;    // reset RX FIFO (pointer to 0)
//        SpiaRegs.SPIFFRX.bit.RXFIFORESET = 1U;    // re-enable RX FIFO operation
    }
        

    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}


interrupt void timing_isr()
{
    // Ler o registrador do contador
    //Timer0_count_before = CpuTimer0Regs.TIM.all;

    // Seta o flag de varredura dos sensores I2C quando da temporização
    // externa, feita pelo sinal TIMEPULSE2 do GPS u-blox LEA-6T.
    I2CRead_flag = 1U;
    
    if (g_internal_timing)
    {
        // Desabilita a interrupção do ePWM responsável pela temporização interna (DSP)
        EPwm1Regs.ETSEL.bit.INTEN = 0U;        // interrupt disable for ePWM1
        g_internal_timing = 0U;
    }
    // Incluir aqui o comando para zerar o contador do Timer0
    // Zera o Timer0 - Neste momento, as interrupções de temporização estão sendo feitas
    // pelo sinal timepulse vindo do GPS à cada 20 ms (1/50). Se o timepulse não vier, 
    // esta ISR não será chamada, e consequentemente, a ISR do Timer0 irá entrar em ação,
    // pois ela tem período de 20,1 ms.
    CpuTimer0Regs.TIM.all = 0U;

    // Alterna o estado do pino de saída GPIO6
//    GpioDataRegs.GPATOGGLE.bit.GPIO6 = 1U;    

    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}


interrupt void ePWM1A_compare_isr(void)
// ISR runs every 20 ms (PWM-frequency = 50 Hz)
// and is triggered by ePWM1 compare event
// run - time of ISR is 630 ns
{
    // Seta o flag de varredura dos sensores I2C quando da temporização
    // interna, feita pelo próprio DSP.
    I2CRead_flag = 1U;
    
    // Alterna o estado do pino de saída GPIO6
    //GpioDataRegs.GPATOGGLE.bit.GPIO6 = 1U;    

    // Zera o Timer0 - Neste momento, as interrupções de temporização estão sendo feitas
    // pelo ePWM à 50 Hz. Resetando o Timer0 a cada 20 ms (1/50), impede-o de gerar 
    // interrupção de timeout pela ausência do sinal Timepulse vinda do GPS.
    CpuTimer0Regs.TIM.all = 0x00000000U;

    // Timing done internally
    g_internal_timing = 1U;

       // Service watchdog every interrupt
       EALLOW;
    SysCtrlRegs.WDKEY = 0xAAU;        // Service watchdog #2
    EDIS;
     
    EPwm1Regs.ETCLR.bit.INT = 1U;        // Clear ePWM1 Interrupt flag
    
       // Acknowledge this interrupt to receive more interrupts from group 3 of 12
       PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;
}


interrupt void cpu_timer0_isr(void)
{
    CpuTimer0.InterruptCount++;

    // Timing done internally
    g_internal_timing = 1U;

    // Reset ePWM1 counter
    EPwm1Regs.TBCTR = 0U;

    // If timeout (t > 20,1 ms) ocurred, a Timer0 interrupt is triggered and
    // the timing is done internally by ePWM1.
    EPwm1Regs.ETSEL.bit.INTEN = 1U;        // interrupt enable for ePWM1

    EALLOW;
    SysCtrlRegs.WDKEY = 0xAAU;    // service WD #2
    EDIS;

    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}


interrupt void cpu_timer1_isr(void)
{
    extern uint8_t gps_in_flag;
    extern uint8_t gps_in_index;
    extern uint8_t gps_in[200];
    int i, len;    
    
    len = SciaRegs.SCIFFRX.bit.RXFFST;

    // check if there is any byte in the RXFIFO, if does, read them...
    if (len != 0U)
    {
        for (i = 0U; i < len; i++)
             gps_in[gps_in_index++] = SciaRegs.SCIRXBUF.bit.RXDT;    
    }

    gps_in_index = 0U;        // reset gps_in_index
    StopCpuTimer1 ();        // stops Timer1 counter
    gps_in_flag = 1U;        // 0: incoming GPS message through SCI-A
                            // 1: completed GPS message

    GpsMessageReady = 1U;

    SciaRegs.SCIFFRX.bit.RXFIFORESET = 0U;    // reset RX-FIFO pointer  
    SciaRegs.SCIFFRX.bit.RXFIFORESET = 1U;    // enable RX-operation
//    PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;
}

/*
// I2C FIFO Interrupt Service
interrupt void I2C_fifo_isr(void)
{

    I2caRegs.I2CFFRX.bit.RXFFINTCLR = 1U;      // clear ISR
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;    
}
*/



/*
// I2C basic Interrupt Service
interrupt void I2C_basic_isr(void)
{

    unsigned int IntSource;

   // Read interrupt source
   IntSource = I2caRegs.I2CISRC.all;

   if(IntSource == 3U)            // ARDY
   {
        // Send new start condition and initiate read
        // continue with Master - Receiver - part
        I2caRegs.I2CCNT    = bytesToRead;                // Enviar bytesToRead bytes [tentar usar bytesToRead para configurar on-the-fly o nível de interrupção da FIFO] 
        I2caRegs.I2CMDR.all = 0x6C20U;                // Master-receiver, Start, Stop after all bytes trans.
        //    Bit15 = 0;    no NACK in receiver mode
        //    Bit14 = 1;  FREE on emulation halt
        //    Bit13 = 1;  STT  generate START 
        //    Bit12 = 0;    reserved
        //    Bit11 = 1;  STP  generate STOP
        //    Bit10 = 1;  MST  master mode
        //    Bit9  = 0;  TRX  master - receiver mode
        //    Bit8  = 0;    XA   7 bit address mode
        //    Bit7  = 0;  RM   nonrepeat mode, I2CCNT determines # of bytes
        //    Bit6  = 0;  DLB  no loopback mode
        //    Bit5  = 1;  IRS  I2C module enabled
        //    Bit4  = 0;  STB  no start byte mode
        //    Bit3  = 0;  FDF  no free data format
        //    Bit2-0: 0;  BC   8 bit per data byte    
    }


    PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;    
}    
*/

//===========================================================================
// End of SourceCode.
//===========================================================================
